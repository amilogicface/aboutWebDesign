# About JavaScript:

## Приведение типов:

### Булевые приведения:

> Перед операцией приведения строки в число обрезаются все знаки табуляций и переносов строки (\n \t и другие).

1. **0**, **''**, **undefined**, **null**, **NaN** всегда приводятся к **false**. Все остальные значения приводятся к **true** (в том числе строчка с 0);
2. **Двойное отрицание (!!)** преобразует любое выражение в булевый тип.

> **True** косвенно равняется **1** а **false**, **null** и **пустые массивы** косвенно равняются **0**;
>> Однако *ТОЛЬКО В НЕСТРОГОМ РАВЕНСТВЕ* **null == 0** и **{} == 0** дают **false**!

### Арифметические приведения:

> Любые арифметические операции **выполняются слева на право** при одинаковом приоритете операторов, потом выполняется операция присваивания.

1. **Любые операции** с любыми типами и значением **undefined** возвращают **NaN**;
2. **Любые операции с объектом и иными типами** приводятся к строке по типу *10\[Object, Object\]*;
2. Опертор **+ со строками** всегда возвращает строку (другие арифметические операторы со **строковыми числами** - числа);
3. **Все операторы с разнотипными строками** возвращают **NaN**;

> То есть: если строка не может через приведение типов стать числом, то все выражение приводится к результату **NaN**.

### Приведения при сравнениях (> < == и подобных):

1. **Если в сравнении есть хоть одно число**, то все другие значения приводятся к числам;
> **Особенность:** '01' == 1 - будет true, так как 0 в строке будет удален, но и '0' == 0 - будет true, так как тут он удален не будет.
2. Если в сравнении только строки, то они сравниваются по правилами сравнения строк;
> **Например:** '2' > '12' - будет true, так как первый символ (2) больше символа 1. 

## Явное приведение типов:

Осуществляется через специальные методы:

1. К числу через **Number()** или через **унарный +**;

> **Например:** let x = false; console.log(+x) - будет 0;

2. К строке через **String()**;
3. К логическому через **Object()**;

> Логическое преобразование самое полезное и может использоваться по многих вещах.
>> **Объект и массив** (даже пустые) при таком преобразовании возвращают **true**!

## Хорошая практика:

1. **Избегать магических чисел**, то есть спонтанных, необозначенных в переменных чисел.

> Например, для перевода долларов в рубли хорошо создать переменную rublesPerDollar, в которой будет находиться нужный множитель.

2. Лучше **как можно чаще использовать константы** в качестве переменных, которые постоянны;

> Это в разы улучшает качество кода и весьма сильно помогает находить ошибки в отдаленной перспетиве.

3. Вместо конкатенации ('string ' + 'string') строк **использовать интерполяцию** (\`${} ${}\`);

## Приоритет выполнения логических операций:

> **name === ('Tom' || 'Bob')** - работает совсем не так как ожидается. Для правильноой работы это выражение должно быть записано так: **name === 'Tom' || name === 'Bob'**.
>> В тоже время для выполнения длинных арифметических операций с примесью буллевых **всегда следует использовать скобки**!

1. Если в логической последовательности полностью отсутствует true значение, то **будет отдано последнее значение**.

> **Например:** let i = false || false || '' - отдаст '', хотя оно при приведении типов тоже равняеться false.

2. **Для нахождения только неопределенных значений** следует использовать оператор **??** вместо **||**.

> **Причина:** оператор **||** считает многие полезные значения ложными, в то время как оператор **??** считает ложными только **undefined** и **null**!

## Объекты:

1. **Добавление свойств** происходит через **точечную нотацию** (user.name == 'Bob') - добавит свойство name со значением 'Bob';
2. **Удаление свойства** происходит через оператор delete и точечную нотацию;
3. Для создания изменяемых в будущем значений свойств можно применять **короткие свойства** (let user = {name,} - тоже самое что let user = {name: name,}). 

> **Важно:** имена свойств с пробелом должны заключаться в ковычки. Добавление/удаление и доступ к таким свойствам осуществляется через **скобочную нотацию** (user\['user name'\] = 'Bob').
>> 1. **Такой способ доступа гораздо лучше точечного**, ибо он имеет доступ к любым свойствам объекта и может обрабатывать строковые переменные приходящие извне;
>> 2. Такой способ можно использовать для **создания подставляемых и дополняемых значений** внутри самого объекта а также **имен из одних цифр**: let user = {\[property name\]} = 5,} или let user = {\[property name + 'from thing'\]} = 5,}.