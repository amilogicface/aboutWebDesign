# Что такое GIT:

**Git** - это распределенный подход хранения данных проекта (копия проекта находится как на сервере, так и у каждого разработчика на локальном компьютере).

-   GIT хранит все версии проекта не в виде версий изменений отдельных файлов, но в виде **снимка** всего проекта и его измененных файлов (каждый такой снимок явлется полноценым рабочим проектом).

## Команды GIT после основной настройки:

### git status

Используется для отображения информации о текущем статусе коммита в git и новых изменениях.

### git init

Создает локальный репозиторий в текущей папке.

## Команды GIT в процессе работы:

### git log

Выводит всю историю коммитов, комментариев к ним и их авторов.

### git add

Подготавливает файлы к коммиту (фиксации изменений).

-   Примеры и параметры использования:

1. git add **.** - точка как выбор всех файлов в папке (**-A** - вообще всего репозитория);
2. git add **\*.txt** - выбор всех фалов одного расширения;
3. git add **folderName/\*.txt** - выбор всех файлов одного расширения в определенной папке;
4. git add **folderName/** - все файлы в определенной папке;
5. git add **"\*.txt"** - все файлы расширения txt во всем проекте (всех папках).

### git commit -m

Cоздает снимок подготовленых файлов, то есть независимую версию проекта.

-   Примеры и параметры использования:

1. git commit **-a -m** - тоже самое, что **git add . + git commit -m**.

> **Важно:** делает снимок только тех файлов, которые имеют статус modified (то есть новосозданные файлы пропустит).

2. git commit **--amend -m** - изменяет последний коммит и не создает новый + добавляет свежий комментарий (необязательно).

### git diff & git show

Отображает разницу между текущим НЕОТСЛЕЖИВАЕМЫМ состоянием репозитория и предыдущим (HEAD).

-   Примеры и параметры использования:

1. git diff **--staged** - разница между текущим ОТСЛЕЖИВАЕМЫМ и последним HEAD;
2. git diff **#commitID** - между текущим и искомым по ID коммита;
3. git diff **HEAD^** - через свойства _HEAD^_ и _HEAD~1_ можно ходить по коммитам как по лестнице.

## Команды изменения и передвижения в GIT:

### git reset

Используется для отмены изменений и откату проекта к одному из снимков.

> МОЖЕТ УДАЛИТЬ ВСЮ ИСТОРИЮ ИЗМЕНЕНИЙ!
>
> > При вызове без указания места расположения коммита используется положение - HEAD.

-   Примеры и параметры использования:

1. git reset **--soft** - удаляет все коммиты до указаного HEAD и оставляет все файлы с их изменениями в ОТСЛЕЖИВАЕМОЙ зоне;
2. git reset **--mixed** (По умолчанию) - удаляет все коммиты до указаного HEAD и оставляет все файлы с их изменениями в НЕОТСЛЕЖИВАЕМОЙ зоне (как если бы не написали _git add_);
3. git reset **--hard** - удаляет все коммиты до указаного HEAD и ПОЛНОСТЬЮ изменяет все файлы до их состояния указанного HEAD.

> Не удаляет НЕОТСЛЕЖИВАЕМЫЕ изменения в файлах и сами новые файлы).

-   **ВАЖНО:** в ПУБЛИЧНЫХ репозиториях никогда нельзя делать reset к коммиту после которого я начал добавлять свои коммиты (**МОЖНО ДЕЛАТЬ ТОЛЬКО НОВЫЕ КОММИТЫ**).

### git checkout

Используется для перемещения между коммитами, отдельными файлами и **ветками** (git checkout #branchName + **активизации спулленых веток**) без какого либо влияния на коммиты последующего пути после места назначения.

> HEAD становится в состояние detached - любые изменения будут удаляться сборщиком мусора.
>
> > Можно и создавать ветки так: **git checkout -b #branchName**.

-   Примеры и параметры использования:

1. git checkout **master** - возврат к самому актуальному (свежему) HEAD в ветке;
2. git checkout **HEAD^ -- #fileName.txt(or #path)** - вернет в текущий HEAD файл #fileName.txt из версии HEAD^ с полной заменой (для более глубокого отката);
3. git checkout **-- #fileName.txt(or #path or #.)** - вернет файлы (НЕОТСЛЕЖИВАЕМЫЕ) для отката к версии текущего (ПОСЛЕДНЕГО) HEAD.

> Как же откатить все отслеживаемые изменения (то есть те, которые уже прошли процедуру _git add_)?
>
> > Через комбо: **git reset --mixed** + **git checkout -- .** - что вначале уберет ОТСЛЕЖИВАНИЕ а потом и изменения этих файлов как НЕОТСЛЕЖИВАЕМЫХ.

### git clean -f

Удаляет новосозданные файлы.

> git clean **-n** - предварительно покажет какие файлы будут удаляться.

## Работа с удаленным репозиторием в GIT:

### git remote -v

Служит для просмотра списка существующих удаленных репозиториев.

-   Примеры и параметры использования:

1. git remote **add #localName #outsideURL** - добавление удаленного репозитория по **ссылке** в _#outsideURL_ к которому мы будет обращаться по привязанному имени в _#localName_;
2. git remote **remove #localName** - удалить связь с удаленным репозиторием с именем _#localName_, к котору привязана ссылка _#outsideURL_.

### git clone

-   Параметры: **#outsideURL** + **#folderName**.

Коприрует внешний репозиторий #outsideURL в нашу локальную папку #folderName (необязательно если надо просто в текущую).

> С этой команды идет начало, ибо она избавляет от необходимости прописывать многие другие комманды при старте работы над удаленным проектом.

### git push

Служит для отправки локального репозитория и коммитов на удаленный.

-   Примеры и параметры использования:

1. git push **#localName master** - отправить на удаленный сервер с именем _#localName_ нашу ветку master.

> Это делается постоянно при нужде отправить новые коммиты на удаленный репозиторий!
>
> > Вместо **master** может быть название другой ветки.

2. git push **--delete origin #branchName** - служит для удаления ветки #branchName из удаленного репозитория.

### git pull

Служит для получение файлов с удаленного репозитория (без атрибутов будет скачивать весь проект со всеми включенными в него ветками).

-   Примеры и параметры использования:

1. git pull **#localName master** - получение обновлений главной ветки с удаленного репозитория.

> Можно заменить на **git rebase #localName/#branchName** с предварительным **git fetch** для того, чтобы не создавать коммит слияния если удаленный репозиторий был обнавлен чужими коммитами.

## SSH в GIT и работа с ним:

-   Весь процесс создания SSH ключей и их подключения локально и удаленно находится тут: [как настрость SSH в GIT](https://docs.github.com/ru/authentication/connecting-to-github-with-ssh).

## Ветвление в GIT:

**master** - это сновная (стабильная) ветка проекта. Для добавления нового функционала в проект используют дополнительные ветки в которых и ведется разработка новых фич. После достижения стабильности в такой ветке ее сливают с основной master веткой тем самым добавляя новую функциональность в проект.

### git branch

Служит для создания/удаления новой ветки из положения текущего HEAD или для просмотра текущего местоположения (если используется без атрибутов).

-   Примеры и параметры использования:

1. git branch **-d #branchName** - удаляет ветку с именем #branchName (без -d - создает ветку);

> При работе с удаленным репозиторием ветка удаляется вначале на нем через **git push --delete origin #branchName**, а потом через верхнюю комманду с **большой буквой** D (предварительно нужно выйти из удаляемой ветки).

### git merge

Служит для объединения ветки с веткой master (вызывается из положения HEAD в master).

-   Примеры и параметры использования:

1. git merge **#branchName** - объединяет ветку с именем #branchName с текущим HEAD в ветке master;
2. git merge **--abort** - отменить слияние (например при конфликте).

## Слияние локальной и удаленной веток в GIT:

На самом деле на локальном компьютере хранится 2 ветки: локальная (master) и удаленная (origin master). Из-за этого обновление master происходит в 2 этапа:

-   Этапы и суть обновления при использовании **git pull origin master**:

1. GIT использует комманду **git fetch** для обновления нашей локальной копии удаленной origin master;
2. Потом GIT использует **git merge origin/master** для слияния нашей локальной ветки master с обновленной удаленной копией origin master.

> origin - это то название, которые мы давали удаленному репозиторию через функцию **git remote add #localName #outsideURL**.

## Кофликты слияния в GIT:

Происходят тогда, когда 2 пользователя изменяют один и тот же файл и потом делают свои коммиты. В последующем процессе pull или push GIT не может самостоятельно объединить такие файлы из-за чего это приходится делать вручную посредствам выбора нужной замены в конфликтном файле.

## Перебазирование (rebase) в GIT:

В большой комманде коммиты слияния могут весьма сильно рагрязнять **git log** своими сообщениями. Для избежания этой ситуации можно использовать альтернативу **git merge** - комманду **git rebase**.

> **git merge** все же является более предпочтительным способом, ибо отображает всю истрию изменений.

-   Примеры и параметры использования:

1. Вначале git checkout #branchName а потом git rebase **master** - объединяет ветки так, что вначале идут все коммиты из ветки master а потом из #branchName (этот вариант предпочтителен);
2. Вначале git checkout master а потом git rebase #branchName - объединяет ветки так, что вначале идут все коммиты из ветки #branchName а потом из master.

> Разрешения конфликтов такое же как и у merge - вручную (+ после исправлений нужно будет написать **--сontinue**) или через отмену посредствам **--abort**.
>
> > Поскольку ветки после этого не удаляются, то нужно потом делать **git merge #branchName** для переноса всего в ветку master и далее удалять ненужную ветку!

## Интерактивный rebase в GIT:

Работает на одной ветке и используется для изменения коммитов. При использовании может происходить весьма много конфликтов при пересечении между коммитами.

-   Примеры и параметры использования:

1. git rebase **-i HEAD~3** - будет изменять коммиты начиная с указанного (то есть с 3-го с конца) и поместит эти коммиты во временную зону после чего выполнит их по порядку в соответствии с выбранными опциями.

> **Опции редактора:**
>
> 1. Поменять местами - просто переставить коммиты местами;
> 2. Вместо pick написать reword - можно будет изменить комментарий коммита;
> 3. Написать squash - объединит этот коммит с предыдущим;
> 4. Написать edit - позволяет полностью изменить содержание коммита и добавить какие-либо изменения в соответствующие файлы, принадлежащие этому коммиту;
>     > Далее необходимо добавить измененные файлы в видимую зону через **git add**, потом ввести **git commit --amend**, где потребуется изменить название коммита, после чего продолжить процедуру rebase через **git rebase --continue**.

## Перенос коммитов из ветки в вету в GIT:

### git cherry-pick

Используется для переноса отдельных коммитов из одной ветки в другую. Применяется из той ветки, в которую необходимо сделать перенос.

-   Примеры и параметры использования:

1. git cherry-pick **#commitID** - перенесет коммит с номером #commitID в текущую ветку после HEAD;
2. git cherry-pick **--edit #commitID** - позволяет дополнительно изменить комментарий коммита;
3. git cherry-pick **--no-commit #commitID** - не делает коммит сразу а добавляет изменения или дополнения переносимого коммита в отслеживаемую зону текущего HEAD;

> Таким образом можно сделать несколько cherry-pick подряд (указываются через пробел) и только потом сделать один общий коммит!

4. git cherry-pick --signoff - указывает в сообщении коммита имя того пользователя, который совершил этот самый cherry-pick.

> -x позволяет засунуть в комментарий коммита ID коммита, который был использован для операции cherry-pick.

## Для себя:

1. **Pull request** - есть только в веб приложении GIT (это одобряемый тим-лидом pull моих изменений в к себе в ветку master).

> **Как это сделать:** вначале надо сделать fork (то есть push моей локальной branch) на удаленный репозиторий и уже оттуда, из веб версии GIT и моего последнего коммита сделать pull request в ветку master.

> **Как отменить уже произошедший merge:** через опцию **revert** в веб версии GIT (в ячейке pull request - вкладка **close**). После этого будет создан новый коммит в ветке master с ее состоянием до слития.

2. На реальном проекте неоходимо довольно **часто делать pull** ветки original master в свою branch для синхронизации изменений к последующему pull request своих изменений в master!
3. **--force** - позволяет принудительно что-то сделать (например переписать коммиты на удаленном репозитории при push).
4. Опция --fixup при git rebase -i склеивает выбранные коммиты в один комит (это то, что я хотел научиться делать) (потом пушим все со свойством --force)
